
```{r, setup, echo = FALSE, message = FALSE}
knitr::opts_chunk$set(
  comment = "#>",
  tidy = FALSE,
  error = FALSE,
  fig.width = 8,
  fig.height = 8)
```

# async

> Asynchronous HTTP

[![Linux Build Status](https://travis-ci.org/r-lib/async.svg?branch=master)](https://travis-ci.org/r-lib/async)
[![Windows Build status](https://ci.appveyor.com/api/projects/status/github/r-lib/async?svg=true)](https://ci.appveyor.com/project/gaborcsardi/async)
[![](http://www.r-pkg.org/badges/version/async)](http://www.r-pkg.org/pkg/async)
[![CRAN RStudio mirror downloads](http://cranlogs.r-pkg.org/badges/async)](http://www.r-pkg.org/pkg/async)
[![Coverage Status](https://img.shields.io/codecov/c/github/r-lib/async/master.svg)](https://codecov.io/github/r-lib/async?branch=master)

The `async` package brings asynchronous (async) computation and I/O to R.
It uses an event loop to schedule asynchronous functions that
report their results via deferred values.

## Installation

```{r eval = FALSE}
devtools::install_github("r-lib/async")
```

## Introduction

The `async` package brings asychronous I/O and computation to R. As a first
step it implements asynchronous HTTP requests.

## Deferred Values

Asynchronous computation is represented by deferred values. In `async`
a deferred value is an R6 object, so it has reference semantics.
In some other programming languages deferred values are called futures
or promises.

You can think of a deferred value as a placeholder for
a (non-deferred) value that is not yet known. A deferred value can be in
three states:
* pending
* fulfilled
* rejected

It starts up in the pending state, and once it is fulfilled or rejected,
it cannot change.

Typically a deferred value is created by requesting asynchronous I/O, like
an HTTP GET request with the `http_get()` function.

## Deferred chains

While the eventual value of a pending deferred is not known, we can still
operate on it, by declaring code that is executed, once the value will be
known:

```{r}
library(async)
def <- http_get("https://httpbin.org")
status <- def$then(function(response) response$status_code)
status
status$get_state()
```

`then()` returns another deferred, which is also chainable. It is possible
to split the chain, and call the `then()` method on the same deferred
multiple times.

## Synchronization

The `await()` function allows mixing synchronous and asynchronous code.
It can be called on a deferred value, and it stops the synchronous
computation until the deferred value is resolved (i.e. fulfilled or
rejected). Importantly `await()` runs an event loop that is working on the
resolution of all deferred values. `await()` calls don't lead to a
deadlock.

In a typical application, a function is implemented asynchronously, and
then used synchronously by the interactive user, or another piece of
synchronous code, via `await()` calls. The following example makes three
HTTP requests in parallel:

```{r}
http_status <- function(url) {
  http_get(url)$then(function(response) response$status_code)
}
r1 <- http_status("https://httpbin.org/status/403")
r2 <- http_status("https://httpbin.org/status/404")
r3 <- http_status("https://httpbin.org/status/200")
await_all(r1, r2, r3)
```

`await_all()` waits until all supplied deferred values are resolved.
Note that
```
await_all(r1, r2, r3)
```
is completely equivalent to
```
await(r1)
await(r2)
await(r3)
```
since an `await()` works towards the resolution of all deferreds, not just
the specified ones. `await_all()` is easier to use programmatically if you
have a list of deferred values. Other `await()` flavours are `await_any()`
and `await_all()`.

## Error handling

There are essentially two ways to handle errors in asynchronous code.
`then()` can take a second argument, another function, that is called
if and when the deferred value is rejected. This function catches the
error and may turn it into a regular value:

```{r}
u1 <- http_get("https://httpbin.org")$
  then(function() "web server is up", function() "web server is down")
u2 <- http_get("non-existing-url.for-sure")$
  then(function() "web server is up", function() "web server is down")
await(u1)
await(u2)
```

The `catch()` method is handy to write an error handler only, it is
equivalent to `then()` with its first argument being `NULL`.

Errors can also be handled synchronously. If an error is not handled
asynchronously in a `then()` or `catch()` method, then the deferred value
will throw an error when it is `await()`-ed. This can be caught via
`tryCatch()`.

## Async Iterators

`async` provides some utilities that make it easier to deal with
collections of deferred values. E.g. `async_map()` applies an async function
to a list and returns a single deferred value for the whole result.
`async_detect()` find a value in a list that satisfies an async predicate
function, etc.

Here is a list of the iterators:
* `async_map()` applies an async function to all elements of a vector or
  list (collection).
* `async_detect()` detects an element of a collection that passed an async
  truth test.
* `async_every()` checks if every element of a collection satisfies an async
  predicate. `async_some()` checks if any element does that.
* `async_filter()` keeps elements that pass an async truth test.
* `async_timeout()` runs an async function with a timeout.

## Async Flow Control

Flow control with deferred values can be challenging. Some helpers:
* `async_reflect()` creates an anonymous function that always succeeds.
  This is useful if you want to apply it to a collection, and don't
  want to stop at the first error.
* `async_retry()` tries an async function a number of times.
  `async_retryable()` turns a regular function into a retryable one.
* `async_sequence()` chains two async function. Calling their sequence is
  equivalent calling `then()` on them, but `async_sequence()` is easier to
  use programmatically.
* `async_until()` and `async_whilst()` lets you call an async function
  repeatedly, until or while a (syncronous or asynchronous) condition
  holds.

## Other Async Utilities

* `async()` converts a synchronous function to async.
* `async_constant()` takes a value and creates and asynchronous function
  that returns that value.
* `when_all()` returns a deferred value that is resolved if all supplied
  deferred values are resolved. `when_any()` and `when_some()` are similar,
  but condition on a single, or the specified number of deferred values.

## Examples

### Parallel API Queries

Query the crandb API, get the authors of the packages with the most
reverse dependencies.

```{r}
fromJSON <- function(x) jsonlite::fromJSON(x, simplifyVector = FALSE)
get_author <- function(package) {
  url <- paste0("https://crandb.r-pkg.org/", package)
  http_get(url)$
    then(~ fromJSON(rawToChar(.$content)))$
    then(~ .$Author)
}

gx <- http_get("https://crandb.r-pkg.org/-/topdeps/devel")$
  then(~ fromJSON(rawToChar(.$content)))$
  then(~ names(unlist(.)))$
  then(~ async_map(., get_author))

await(gx)[1:3]
```

### Checking URLs

The following code returns the 2 URLs that respond first.

```{r}
urls <- c("https://cran.rstudio.com", "https://cran.r-project.org",
          "https://www.stats.bris.ac.uk/R/", "https://cran.uib.no/")
qs <- lapply(urls, http_head)
t2 <- when_some(2, .list = qs)$
  then(function(top2) vapply(top2, "[[", character(1), "url"))
await(t2)
```

## License

MIT Â© [RStudio Inc](https://rstudio.com)
