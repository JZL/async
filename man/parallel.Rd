% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/parallel.R
\name{parallel}
\alias{parallel}
\title{Run a list of functions in parallel}
\usage{
parallel(tasks, callback)
}
\arguments{
\item{tasks}{A list (or collection) of async functions to run. Each
async function can complete with any number of optional result values.}

\item{callback}{A callback to run once all the functions have
completed successfully. This function gets a results list
containing all the result arguments passed to the task
callbacks. Invoked with \code{(err, results)}.}
}
\value{
Task id.
}
\description{
Run a list of functions in parallel, without waiting until
the previous function has completed. If any of the functions pass an
error to its callback, the main callback is immediately called with the
value of the error. Once the tasks have completed, the results are
passed to the final callback as an array.
}
\details{
Note: \code{parallel} is about kicking-off I/O tasks in parallel, not about
parallel execution of code. If your tasks do not use any timers or
perform any async I/O, they will actually be executed in series. Any
synchronous setup sections for each task will happen one after the
other.

Hint: Use \code{\link[=reflect]{reflect()}} to continue the execution of other tasks when a
task fails.
}
\examples{
res <- NULL
wait_for(parallel(
  list(
    function(callback) {
      http_get("https://eu.httpbin.org/get?q=foo",
               function(err, res) callback(err, rawToChar(res$content)))
    },
    function(callback) {
      http_get("https://eu.httpbin.org/get?q=bar",
               function(err, res) callback(err, rawToChar(res$content)))
    }
  ),
  function(err, result) { res <<- result }
))
length(res)
cat(res[[1]])
}
\seealso{
Other async control flow: \code{\link{parallel_limit}},
  \code{\link{retryable}}, \code{\link{retry}},
  \code{\link{sequence}}, \code{\link{until}},
  \code{\link{waterfall}}, \code{\link{whilst}}
}
